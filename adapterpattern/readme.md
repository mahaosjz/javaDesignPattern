# adapter patter 适配器模式
#### 定义
将一个接口转换成客户希望的另一个接口，使得不兼容的类可以一起工作，其别名为包装器（Wrapper）。
## 2.对象适配器模式
适配器和适配者之间是关联关系
1. Target（目标抽象类）：客户所需接口。
2. Adapter（适配器类）：适配器可以调用另一个接口，作为转换器对Adaptee和Target进行适配。通过继承Target并关联一个Adaptee对象
使得二者产生联系。
3. Adaptee（适配者类）：定义一个已经存在的接口，该接口需要适配，一般是一个具体类。
## 3.类适配器
适配器和适配者是继承关系，并且实现了抽象目标类接口。
使用较少，原因
1. java不支持多重类继承；
2. 目标抽象类不是接口，是一个类，无法使用；
3. 适配者是final类，无法使用。
## 4.双向适配器
在适配器中同时包含对目标类和适配者类的引用，适配者可以通过 它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法。
```java
class	Adapter	implements	Target,Adaptee	{							
    //同时维持对抽象目标类和适配者的引用						
    private	Target	target;					
    private	Adaptee	adaptee;						
    public	Adapter(Target	target)	{										
        this.target	=	target;						
    }					
    public	Adapter(Adaptee	adaptee)	{		
        this.adaptee	=	adaptee;		
    }			
    public	void	request()	{								
        adaptee.specificRequest();					
    }					
    public	void specificRequest()	{							
        target.request();					
    }	
}

```

## 5.缺省适配器
当不需要实现接口所提供的所有方法是，可以先涉及一个抽象类实现接口，并为该接口每个方法提供要给默认实现，抽象类的字类可以选择性
的覆盖符类的方法来实现需求。又称为单接口适配器模式
1. ServiceInterface（适配器接口）：接口中提供了大量的方法。
2. AbstractServiceClass（缺省适配器类）：核心类，使用空方法实现了适配者接口的方法，定义为抽象类。
3. ConcreteServiceClass（具体业务类）：缺省适配器类的字类，选择性的覆盖父类中定义的方法

## 优点
1. 目标类和适配者类解耦，无需修改原有结构
2. 增加类的透明性和复用性，对于客户端而且是透明的，提高了适配者的复用性。
3. 灵活性和扩展性较好。
4. 对象适配器模式，可以把多个不同的适配者适配到同一个目标。
5. 对象适配器模式，可以适配一个适配者的子类。
## 缺点
1. java只能适配一个适配者类，不能同时适配多个适配者.
2. 适配者不能是final，
3. 类适配器模式中抽象目标类只能是接口。
4. 对象适配器要在适配器中置换适配者类的某些方法比较麻烦

## 适用场景
1. 需要适用一些现有的类，但现有的类不符合系统的需要或者没有源代码
2. 创建一个可以重复使用的类，用于与一些彼此之间没有太大关系的类，包括一些可能在将来引进的类一起工作。
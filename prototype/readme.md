# 原型链模式
原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类本身，工厂方法由克隆方法来实现。

### 1.实现Cloneable接口
标识当前类支持复制，但是实现的是浅克隆，当对象被复制时只复制它本身和其中包含的值类型的成 员变量，而引用类型的成员对象并没有复制，

### 2.实现Serializable接口
可通过序列化方式实现，将对象写到流的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。实现深克隆。

## 优点
1. 当创建新的实例对象比较复杂时，可使用原型模式，提高创建新对象的效率
2. 扩展性较好，原型模式提供了抽象类，可以针对抽象原型进行编程，将具体原型类卸载配置文件中，增加或减少产品类对系统没有影响。
3. 工厂方法需要一个与产品类等级结构相同的工厂等级结构，而原型模式通过克隆方法实现，无需专门的工厂类来实现。
4. 使用深克隆可以保存对象的状态，以便需要时可以辅助实现撤销操作。
## 缺点
1. 克隆方法位于类的内部，对已有类进行改造时，需要修改源码，违反了“开闭原则”；
2. 为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较繁琐

## 适用场景
1. 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的 对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修 改。
2. 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用 原型模式配合备忘录模式来实现。
3. 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组 合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便
